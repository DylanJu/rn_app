"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const React = require("react");
const LayoutType_1 = require("./LayoutType");
const LayoutTreeCrawler_1 = require("./LayoutTreeCrawler");
const UniqueIdProvider_mock_1 = require("../adapters/UniqueIdProvider.mock");
const Store_1 = require("../components/Store");
const ts_mockito_1 = require("ts-mockito");
const OptionsProcessor_1 = require("./OptionsProcessor");
describe('LayoutTreeCrawler', () => {
    let uut;
    let store;
    beforeEach(() => {
        store = new Store_1.Store();
        const mockedOptionsProcessor = ts_mockito_1.mock(OptionsProcessor_1.OptionsProcessor);
        const optionsProcessor = ts_mockito_1.instance(mockedOptionsProcessor);
        uut = new LayoutTreeCrawler_1.LayoutTreeCrawler(new UniqueIdProvider_mock_1.UniqueIdProvider(), store, optionsProcessor);
    });
    it('crawls a layout tree and adds unique id to each node', () => {
        const node = { type: LayoutType_1.LayoutType.Stack, id: 'Stack+UNIQUE_ID', children: [{ id: 'BottomTabs+UNIQUE_ID', type: LayoutType_1.LayoutType.BottomTabs, data: {}, children: [] }], data: {} };
        uut.crawl(node);
        expect(node.id).toEqual('Stack+UNIQUE_ID');
        expect(node.children[0].id).toEqual('BottomTabs+UNIQUE_ID');
    });
    it('does not generate unique id when already provided', () => {
        const node = { id: 'user defined id', type: LayoutType_1.LayoutType.Stack, data: {}, children: [] };
        uut.crawl(node);
        expect(node.id).toEqual('user defined id');
    });
    it('crawls a layout tree and ensures data exists', () => {
        const node = { type: LayoutType_1.LayoutType.Stack, children: [{ type: LayoutType_1.LayoutType.BottomTabs, data: {}, children: [] }], data: {} };
        uut.crawl(node);
        expect(node.data).toEqual({});
        expect(node.children[0].data).toEqual({});
    });
    it('crawls a layout tree and ensures children exists', () => {
        const node = { type: LayoutType_1.LayoutType.Stack, children: [{ type: LayoutType_1.LayoutType.BottomTabs, data: {}, children: [] }], data: {} };
        uut.crawl(node);
        expect(node.children[0].children).toEqual([]);
    });
    it('saves passProps into store for Component nodes', () => {
        const node = {
            type: LayoutType_1.LayoutType.BottomTabs,
            children: [{ type: LayoutType_1.LayoutType.Component, data: { name: 'the name', passProps: { myProp: 123 } }, children: [] }],
            data: {}
        };
        expect(store.getPropsForId('Component+UNIQUE_ID')).toEqual({});
        uut.crawl(node);
        expect(store.getPropsForId('Component+UNIQUE_ID')).toEqual({ myProp: 123 });
    });
    it('Components: injects options from original component class static property', () => {
        const theStyle = {};
        const MyComponent = class CoolComponent extends React.Component {
            static get options() {
                return theStyle;
            }
        };
        const node = { type: LayoutType_1.LayoutType.Component, data: { name: 'theComponentName', options: {} }, children: [] };
        store.setComponentClassForName('theComponentName', () => MyComponent);
        uut.crawl(node);
        expect(node.data.options).toEqual(theStyle);
    });
    it('Components: crawl does not cache options', () => {
        const optionsWithTitle = (title) => {
            return {
                topBar: {
                    title: {
                        text: title
                    }
                }
            };
        };
        const MyComponent = class CoolComponent extends React.Component {
            static options(props) {
                return {
                    topBar: {
                        title: {
                            text: props.title
                        }
                    }
                };
            }
        };
        const node = { type: LayoutType_1.LayoutType.Component, data: { name: 'theComponentName', options: {}, passProps: { title: 'title' } }, children: [] };
        store.setComponentClassForName('theComponentName', () => MyComponent);
        uut.crawl(node);
        expect(node.data.options).toEqual(optionsWithTitle('title'));
        const node2 = { type: LayoutType_1.LayoutType.Component, data: { name: 'theComponentName', options: {} }, children: [] };
        uut.crawl(node2);
        expect(node2.data.options).toEqual(optionsWithTitle(undefined));
    });
    it('Components: passes passProps to the static options function to be used by the user', () => {
        const MyComponent = class CoolComponent extends React.Component {
            static options(passProps) {
                return { foo: passProps.bar.baz.value };
            }
        };
        const node = { type: LayoutType_1.LayoutType.Component, data: { name: 'theComponentName', passProps: { bar: { baz: { value: 'hello' } } }, options: {} }, children: [] };
        store.setComponentClassForName('theComponentName', () => MyComponent);
        uut.crawl(node);
        expect(node.data.options).toEqual({ foo: 'hello' });
    });
    it('Components: passProps in the static options is optional', () => {
        const MyComponent = class CoolComponent extends React.Component {
            static options(passProps) {
                return { foo: passProps };
            }
        };
        const node = { type: LayoutType_1.LayoutType.Component, data: { name: 'theComponentName', options: {} }, children: [] };
        store.setComponentClassForName('theComponentName', () => MyComponent);
        uut.crawl(node);
        expect(node.data.options).toEqual({ foo: {} });
    });
    it('Components: merges options from component class static property with passed options, favoring passed options', () => {
        const theStyle = {
            bazz: 123,
            inner: {
                foo: 'bar'
            },
            opt: 'exists only in static'
        };
        const MyComponent = class CoolComponent extends React.Component {
            static get options() {
                return theStyle;
            }
        };
        const passedOptions = {
            aaa: 'exists only in passed',
            bazz: 789,
            inner: {
                foo: 'this is overriden'
            }
        };
        const node = { type: LayoutType_1.LayoutType.Component, data: { name: 'theComponentName', options: passedOptions }, children: [] };
        store.setComponentClassForName('theComponentName', () => MyComponent);
        uut.crawl(node);
        expect(node.data.options).toEqual({
            aaa: 'exists only in passed',
            bazz: 789,
            inner: {
                foo: 'this is overriden'
            },
            opt: 'exists only in static'
        });
    });
    it('Component: deepClones options', () => {
        const theStyle = {};
        const MyComponent = class CoolComponent extends React.Component {
            static get options() {
                return theStyle;
            }
        };
        const node = { type: LayoutType_1.LayoutType.Component, data: { name: 'theComponentName', options: {} }, children: [] };
        store.setComponentClassForName('theComponentName', () => MyComponent);
        uut.crawl(node);
        expect(node.data.options).not.toBe(theStyle);
    });
    it('Components: must contain data name', () => {
        const node = { type: LayoutType_1.LayoutType.Component, data: {}, children: [] };
        expect(() => uut.crawl(node)).toThrowError('Missing component data.name');
    });
    it('Components: options default obj', () => {
        const MyComponent = class extends React.Component {
        };
        const node = { type: LayoutType_1.LayoutType.Component, data: { name: 'theComponentName', options: {} }, children: [] };
        store.setComponentClassForName('theComponentName', () => MyComponent);
        uut.crawl(node);
        expect(node.data.options).toEqual({});
    });
    it('Components: omits passProps after processing so they are not passed over the bridge', () => {
        const node = {
            type: LayoutType_1.LayoutType.Component,
            data: {
                name: 'compName',
                passProps: {}
            },
            children: []
        };
        uut.crawl(node);
        expect(node.data.passProps).toBeUndefined();
    });
    describe('LayoutNode', () => {
        it('convertable from same data structure', () => {
            const x = {
                id: 'theId',
                type: LayoutType_1.LayoutType.Component,
                data: {},
                children: []
            };
            let got;
            function expectingLayoutNode(param) {
                got = param;
            }
            expectingLayoutNode(x);
            expect(got).toBe(x);
        });
    });
});
